## 도메인 모델 패턴
- 표현 (Controller) => 응용(Service) => 도메인(domain) => 인프라스트럭쳐 (DB)

## 도메인 영역의 주요 구성요소
- 엔티티(Entitiy) : 고육의 식별자를 갖는 객체 
- 밸류(Value) : 고유의 식별자를 갖지 않는 객체로 주로 개념적인 하나인 도메인 객체의 속성을 표현. 엔티티의 속성이나 다른 밸류 타입의 속성으로 사용된다.
- 애그리거트(Aggregate) : 관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것
- 리포지터리(Repository) : 도메인 모델의 영속성을 처리한다.
- 도메인 서비스(Domain Service) : 특정 엔티티에 속하지 않은 도메인 로직을 제공한다. 여러 엔티티와 밸류를 필요할 경우 도메인 서비스에서 로직을 구현

## 도메인 모델 엔티티 vs DB 모델 엔티티
- 도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공
- 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현
  - 예를 들어 RDMS에 주문자를 표현하려면 Order(주문) 테이블에 orderer_name, orderer_email을 같이 넣거나 테이블을 분리해서
  order (no, orderer_name, orderer_email), order_orderer (order_no, orderer_name, orderer_email) 중복되게 저장 해야 된다.

## JPA에서 Repository Interface 사용 이유
- Interface 자체는 고수준 이기 때문에 Service(고수준)에서 Repositroy(고수준)을 통해 RepositoryImpl(저수준)에 접근한다.
  - 이렇게 하면 인ㅌ프라스트럭처에 의존하면 생기는 2가지 문제 (테스트의 어려움과 기능 확장의 어려움)이 해소된다.
  
## 요청 처리 흐름
![spring](https://user-images.githubusercontent.com/7076334/55076338-7f469180-50d8-11e9-8cad-7e051a12d0d0.jpg)

## 생각해볼점
- 실제 프로젝트 내에서 Service에서 외부 API통신을 하거나 인프라스트럭처 용도를 사용할 때는 인터페이스(고수준)을 두어서 유연하게 만들자.
- 하지만 예외도 있다. 인프라스트럭처에 대한 의존을 일부 도메인에 넣은 코드 (보통 JPA에서 많이 사용하는)
  - ex) @Entity @Table(name = "TBL_ORDER") public class Order {...}

## 애그리거트(Aggregate)
- 경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.
- 도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.
- 하나의 애그리거트 예) 주문할 상품 개수, 배송지 정보, 주문자 정보 (주문 시점에 함께 생성됨)
- 하나의 애그리거트 아닌경우 예) 상품 - 리뷰 (Product 주체는 상품 담당자, Review 주체는 고객)

## 애그리거트 루트
- 애그리거트 전체를 관리할 주체
- 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.
- 애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다! (주의)

## 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들기 위한 두가지 습관
- 단순히 필드를 변경하는 set 메서드를 공개(pubic) 으로 만들지 않는다.
- 밸류 타입은 불변으로 구현한다.

## 트랜잭션 범위
- 트랜잭션 범위는 작을수록 좋다. 범위가 많아질 수록 잠금 대상이 많아져서 전체적인 성능을 떨어뜨린다.
- 한 트랜잭션에서는 한 개의 애그리거트만 수정해야 한다. (책임 범위를 넘어서 결합도가 높아짐)
- 만약 부득이하게 수정해야 한다면 애그리거트에서 다른 애그리거트를 직접 수정하지 말고 응용 서비스에서 수정하도록 해야된다.

## 트랜잭션 제약
- 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 도입할 수 없을 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 유지해야 된다.

## 리포지터리
- 리포지터리는 애그리거트 단위로 존재한다.
- 어떤 기술을 이용해서 리포지터리를 구현하느냐에 따라 애그리거트의 구현도 영향을 받는다.
- Order 애그리거트를 저장할 때 루트와 매핑되는 테이블과 모든 속성을 테이블에 저장해야 된다. 데이터를 불러올 때도 동일하다. (일관성)

## 필드를 이용한 애그리거트 참조의 문제점
- 편한 탐색 오용 : 트랜잭션 제약을 어기게 된다. (하나의 애그리거트에서 다른 애그리거트 수정)
- 성능에 대한 고민 : 지연(lazy)로 할 것이냐, 즉시(eager)로 할 것이냐 성능에 따른 고민
- 확장 어려움 : 도메인마다 다른 DBMS를 사용할 경우 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없다.
  - 해결책 : 아이디를 이용한 간접 참조 (리포지터리마다 다른 저장소를 사용할 수 있어서 확장에 용이)
    - 하지만 성능 이슈 생길 수 있다. (여러번 따로 조회 해야 하기 때문에)
      - 아이디 간접 해결책 : DAO를 만들고 조인을 이용해서 한 번의 쿼리로 필요한 데이터 조회 (쿼리가 복잡할 경우에만 사용 ex)JPQL))
        - 이 방법도 다른 저장소 사용하면 사용 못함 ㅠㅠ. 캐시 처리하거나 조회 전용 저장소를 따로 구성해야 됨
        
## 애그리거트 팩토리
- 애그리거트가 갖고 있는 데이터를 이용해서 다른 애그리거트를 생성해야 한다면 팩토리 메서드를 구현하는 것을 고려해 보자.
    
  










